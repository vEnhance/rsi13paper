% This is paper.tex

\section{Introduction}
\textbf{Note:} If possible, this document should be printed in color.  However, I have left blue lines as solid and red lines as dashed for readability.

We study a class of maps between Bott-Samelson bimodules.  These maps are represented by certain types of diagrams, as described in Section~\ref{sec:prelim_map}.  The maps are composed by juxtaposition.

TODO: Expand on history, motivation, importance, etc. (meeting Ben on Monday)

Given a sequence consisting of the letters $s$ and $t$ of length $n$, as well as a binary string of length $n$, one can construct such a diagram using an algorithm known as Libedinsky's light leaves, as detailed in Section~\ref{sec:prelim_lightleave}.  Since two diagrams may be composed, we may construct a new map given two binary strings by composing the results of two applications of the light leaves.  We describe the relationship between the final result of such a composition and the two binary strings being composed.

Because the technical description of the problem statement is quite involved, we devote the entirety of Section~\ref{sec:prelim} to preliminaries and defer the actual problem statement to Section~\ref{sec:probstate}.  The results begin by solving the special case of one color completely in Section~\ref{sec:res_onecolor}.  In Section~\ref{sec:res_count_maps}, we also present a formula for the number of maps between two given bimodules.  The most interesting results are in Sections~\ref{sec:res_alt_restrict} and \ref{sec:res_alt_compute}, where we investigate the case where the given string is $ststst\cdots$.  In particular, we show that the possible resulting structures is extremely limited, and provide a recursion based on these restrictions for special cases. 

\section{Preliminaries and Definitions}
\label{sec:prelim}
In Appendix~\ref{sec:prelim_background}, we provide the background behind the Bott-Samelson bimodules, and the correspondence between these maps and certain diagrams.  We then introduce Libedinsky's light leaves, a basis by which maps can be constructed using binary strings.

In Section~\ref{sec:prelim_def_notation}, we introduce several definitions which we use throughout the paper.  Next, in Section~\ref{sec:prelim_explain_poly_eval}, we describe how these maps can be represent as polynomials.  The actual problem statement is then deferred to \ref{sec:probstate}.
\subsection{Definitions and Notations}
\label{sec:prelim_def_notation}
Take an infinite dihedral group $W=\left<s,t\mid s^2=t^2=1\right>$ and let $R = \RR[\alpha_s, \alpha_t]$ be the Coxeter ring as defined in Appendix~\ref{sec:prelim_background}, where $\alpha_s$ denotes reflection over the hyperplane normal to $s$.  
\subsubsection{Notations for Strings}
For each positive integer $n$, let us define for convenience the strings
\[ \SS_n \defeq \underbrace{s \dots s}_{\text{$n$ $s$'s}} \] 
and the ``alternating'' string
\[
	\AA_n \defeq
	\begin{cases}
		\underbrace{sts\dots s}_{\text{$n$ letters}} & \text{if } n \equiv 1 \pmod{2} \\
		\underbrace{sts\dots t}_{\text{$n$ letters}} & \text{if } n \equiv 0 \pmod{2}. 
	\end{cases}
\]
Similarly, let $\AA_n'$ denote $\AA_n$, except with the roles of $s$ and $t$ switched.  Note that $\AA_0 = \AA_0' = \varnothing$.

In general, a string of $s$'s and $t$'s will be referred to as an \emph{expression}.  In the case where there are no consecutive identical characters (e.g. the string is either $\AA_n$ or $\AA_n'$), we will refer to them as \emph{reduced expressions}.

Next, let $\BB_n$ denote the set of binary strings of length $n$.

Finally, given a string $\ul x$ (either a binary string or a string of $s$'s and $t$'s) we will denote the $i\th$ character as $\ul x[i]$.

\subsubsection{Definitions for Maps and Diagram}
Consider a string $\ul r$ of letters $s$ and $t$.  Given a binary string $\ul b$, we will let $\MM_{\ul r}(\ul b)$ denote the map (or its associated diagram; we will refer to maps and their associated diagrams interchangeably) formed by the light leaves, as prescribed in Appendix~\ref{sec:prelim_lightleave}.  We will refer to such structures as \emph{half-maps} or \emph{half-diagrams} should such a need arise.  Additionally, let $\Top_{\ul r}(\ul b)$ denote the top of the half-diagram $\MM_{\ul r}(\ul b)$.

\begin{figure}[ht]
	\centering
	\begin{asy}
	size(4cm);
	real h = 0.7;
	pen s = blue, t = red + dashed + 0.6;
	pen dot_s = blue, dot_t = red;
	int n = 7;

	picture one;
	draw(one, (0,0)--(0,h/2)..((0+3)/2.0,h*3)..(3,h/2)--(3,0), s);
	draw(one, (4,0)--(4,h/2)..((4+6)/2.0,h*2)..(6,h/2)--(6,0), t);
	draw(one, (1,0)--(1,h), t);
	dot(one, (1,h), dot_t);
	draw(one, (2,0)--(2,h), t);
	dot(one, (2,h), dot_t);
	draw(one, (5,0)--(5,h), s);
	dot(one, (5,h), dot_s);
	draw(one,(6,0)--(6,4*h), t);
	dot(one, (6, h/2), dot_t);

	picture two;
	draw(two, (0,0)--(0,h/2)..((0+3)/2.0,h*3)..(3,h/2)--(3,0), s);
	draw(two, (1,0)--(1,h), t);
	dot(two, (1,h), dot_t);
	draw(two, (2,0)--(2,h), t);
	dot(two, (2,h), dot_t);
	draw(two, (4,0)--(4,h), t);
	dot(two, (4,h), dot_t);
	draw(two, (5,0)--(5,h), s);
	dot(two, (5,h), dot_s);
	draw(two,(6,0)--(6,4*h), t);

	add(one); add(reflect((0,0),(1,0))*two);
	draw((-1,0)--(7,0));
	\end{asy}
	\caption{An example of composing two maps, $\MM_{sttstst}(1001100)$ and $\MM_{sttstst}(1001001)$.}
	\label{fig:example_compose}
\end{figure}

Two maps $\MM_{\ul r}(\ul a)$ and $\MM_{\ul r}(\ul b)$ with identical tops may be composed by juxtaposing $\MM_{\ul r}(\ul a)$ with a flipped copy of $\MM_{\ul r}(\ul b)$; an example of such a composition is given in Figure~\ref{fig:example_compose}.  We will denote this product by $\MM_{\ul r}(\ul a, \ul b)$.  If the two half-maps are not compatible (that is, $\Top_{\ul r}(\ul a) \neq \Top_{\ul r}(\ul b)$) then we will simply set $\MM_{\ul r}(\ul a, \ul b) = 0$.

Such structures will analogously be called \emph{full-maps} or \emph{full-diagrams} for clarity.  If $\ul r$ is clear from context, we will abbreviate $\MM_{\ul r}$ as simply $\MM$ and $\Top_{\ul r}$ as $\Top$.

Recall that the light leaves are based off a sequence of vertices at the bottom boundary of a half-map.  We will call those vertices, whether on the bottom boundary of a half-map or the center of a full-map, the \emph{anchors} for that map, and the associated sequence of letters the \emph{base}.  

An example of a full-map with base $\AA_5$ is given in Figure~\ref{fig:example_full_map}.

\begin{figure}[ht]
	\centering
	\begin{asy}
		size(4cm);
		real h = 0.7;
		pen s = blue, t = red + dashed + 0.6;
		pen dot_s = blue, dot_t = red;
		int n = 5;

		picture one;
		draw(one, (0,0)--(0,h/2)..((0+2)/2.0,h*2)..(2,h/2)--(2,0), s);
		draw(one, (1,0)--(1,h), t);
		dot(one, (1,h), dot_t);
		draw(one, (3,0)--(3,h), t);
		dot(one, (3,h), dot_t);
		draw(one, (4,0)--(4,h), s);
		dot(one, (4,h), dot_s);

		picture two;
		draw(two, (1,0)--(1,h/2)..((1+3)/2.0,h*2)..(3,h/2)--(3,0), t);
		draw(two, (0,0)--(0,h/2)..((0+4)/2.0,h*4)..(4,h/2)--(4,0), s);
		draw(two, (2,0)--(2,h), s);
		dot(two, (2,h), dot_s);

		add(one); add(reflect((0,0),(1,0))*two);
		draw((-1,0)--(5,0));
	\end{asy}
	\caption{A full-map with base $ststs$, hence with five anchors.  The top is $\varnothing$.}
	\label{fig:example_full_map}
\end{figure}

\subsubsection{Nomenclature for Certain Structures in Diagrams}
Let us make a few convenient definitions for some recurring characters in our full-diagrams.

\begin{figure}[ht]
	\centering
	\begin{asy}
		size(5cm);
		real h = 0.7;
		pen s = blue, t = red + dashed + 0.6;
		pen dot_s = blue, dot_t = red;
		int n = 10;

		picture one;
		draw(one, (4,0)--(4,h/2)..((4+6)/2.0,h*2)..(6,h/2)--(6,0), s);
		draw(one, (3,0)--(3,h/2)..((3+7)/2.0,h*4)..(7,h/2)--(7,0), t);
		draw(one, (2,0)--(2,h/2)..((2+8)/2.0,h*6)..(8,h/2)--(8,0), s);
		draw(one, (1,0)--(1,h/2)..((1+9)/2.0,h*8)..(9,h/2)--(9,0), t);
		draw(one, (5,0)--(5,h), t);
		dot(one, (5,h), dot_t);
		draw(one,(0,0)--(0,9*h), s);

		picture two;
		draw(two, (2,0)--(2,h/2)..((2+4)/2.0,h*2)..(4,h/2)--(4,0), s);
		draw(two, (1,0)--(1,h/2)..((1+5)/2.0,h*4)..(5,h/2)--(5,0), t);
		draw(two, (0,0)--(0,h/2)..((0+6)/2.0,h*6)..(6,h/2)--(6,0), s);
		draw(two, (3,0)--(3,h), t);
		dot(two, (3,h), dot_t);
		draw(two, (7,0)--(7,h), t);
		dot(two, (7,h), dot_t);
		draw(two, (9,0)--(9,h), t);
		dot(two, (9,h), dot_t);
		draw(two,(8,0)--(8,7*h), s);

		add(one); add(reflect((0,0),(1,0))*two);
		draw((-1,0)--(10,0));
	\end{asy}
	\caption{Two blue barbells with a very twisted fence, which creates two pastures.}
	\label{fig:def_barbell_fence}
\end{figure}

\begin{definition*}
	A connected component which (i) is a tree, and (ii) does not touch the top or bottom boundaries is called a \emph{barbell}.
\end{definition*}
Notice that, by homotopy, every blue barbell is simply $\barbell{barbell_blue}$, which we will see later evaluates as $\alpha_s$.  Similarly, every red barbell is simply $\barbell{barbell_red} = \alpha_t$.

\begin{definition*}
	A \emph{fence} is a contiguous path which runs from the top of the boundary to the bottom of the boundary (i.e. paths between the labelled vertices).  The diagram is divided by these fences into \emph{pastures}, which will be numbered from left to right as $0$, $1$, \dots, $k$, where $k$ is the number of fences.  
\end{definition*}
\begin{definition*}
	A component is called \emph{attached} if it is connected to a fence.  Otherwise, it is \emph{free}.  By convention, any attached components belong to the pasture to the left of the associated fence.
\end{definition*}
An example of a fence complete with two barbells is given in Figure~\ref{fig:def_barbell_fence}.

Next, we name some recurrent characters in our work.

% We remind the reader that we are working modulo lower terms; any map which contains a ``half fence'' (i.e. a connected component which touches a boundary exactly once) is not considered.

\begin{figure}[ht]
	\centering
	\begin{asy}
		size(4cm);
		real h = 0.7;
		pen s = blue, t = red + dashed + 0.6;
		pen dot_s = blue, dot_t = red;
		int n = 4;

		picture one;
		draw(one, (0,0)--(0,h/2)..((0+3)/2.0,h*3)..(3,h/2)--(3,0), s);
		draw(one, (1,0)--(1,h), t);
		dot(one, (1,h), dot_t);
		draw(one, (2,0)--(2,h), t);
		dot(one, (2,h), dot_t);

		picture two;
		draw(two, (0,0)--(0,h/2)..((0+3)/2.0,h*3)..(3,h/2)--(3,0), s);
		draw(two, (1,0)--(1,h), t);
		dot(two, (1,h), dot_t);
		draw(two, (2,0)--(2,h), t);
		dot(two, (2,h), dot_t);

		add(one); add(reflect((0,0),(1,0))*two);
		draw((-1,0)--(4,0));
	\end{asy}
	\caption{A blue bubble with two barbells inside it.}
	\label{fig:def_bubble}
\end{figure}

\begin{definition*}
	A \emph{bubble} is a bounded face alongside with any components contained within it.  The \emph{color} of the bubble is the color of the edges which form the bounded face.  
\end{definition*}
\begin{definition*}
	We say that the bubble $B$ \emph{holds} a component $c$ if $c$ is inside $B$, but there is no other bubble $B'$ inside $B$ which contains $c$.  
\end{definition*}

An example of a bubble is given in Figure~\ref{fig:def_bubble}.

\begin{figure}[ht]
	\centering
	\begin{asy}
		size(6cm);
		real h = 0.7;
		pen s = blue, t = red + dashed + 0.6;
		pen dot_s = blue, dot_t = red;
		int n = 7;

		picture one;
		draw(one, (0,0)--(0,h/2)..((0+2)/2.0,h*2)..(2,h/2)--(2,0), s);
		draw(one, (2,0)--(2,h/2)..((2+4)/2.0,h*2)..(4,h/2)--(4,0), s);
		draw(one, (4,0)--(4,h/2)..((4+6)/2.0,h*2)..(6,h/2)--(6,0), s);
		draw(one, (1,0)--(1,h), t);
		dot(one, (1,h), dot_t);
		draw(one, (3,0)--(3,h), t);
		dot(one, (3,h), dot_t);
		draw(one, (5,0)--(5,h), t);
		dot(one, (5,h), dot_t);
		dot(one, (2, h/2), dot_s);
		dot(one, (4, h/2), dot_s);

		picture two;
		draw(two, (0,0)--(0,h/2)..((0+2)/2.0,h*2)..(2,h/2)--(2,0), s);
		draw(two, (2,0)--(2,h/2)..((2+4)/2.0,h*2)..(4,h/2)--(4,0), s);
		draw(two, (4,0)--(4,h/2)..((4+6)/2.0,h*2)..(6,h/2)--(6,0), s);
		draw(two, (1,0)--(1,h), t);
		dot(two, (1,h), dot_t);
		draw(two, (3,0)--(3,h), t);
		dot(two, (3,h), dot_t);
		draw(two, (5,0)--(5,h), t);
		dot(two, (5,h), dot_t);
		dot(two, (2, h/2), dot_s);
		dot(two, (4, h/2), dot_s);

		add(one); add(reflect((0,0),(1,0))*two);
		draw((-1,0)--(7,0));
	\end{asy}
	\caption{A caterpillar made of three bubbles}
	\label{fig:def_caterpillar}
\end{figure}

\begin{definition*}
	A \emph{caterpillar} consists of a free component and the contents of any bubbles it contains.  A caterpillar \emph{holds} a component if some bubble of the caterpillar holds it.
\end{definition*}
An example of a caterpillar is given in Figure~\ref{fig:def_caterpillar}.  Notice that any barbell or bubble is a special case of a caterpillar.


\subsection{Representations of Maps as Polynomials}
\label{sec:prelim_explain_poly_eval}

In order to study these maps as algebraic structures, we wish to consider full-maps as polynomials in $\RR[x,y][\alpha_s,\alpha_t]$.  Hence, we establish the following conventions:
\begin{enumerate}
	\ii The map $x \mapsto fx$ will be abbreviated as $f$ from this point forward.  
	\par Note that, in particular, $\barbell{barbell_blue} = \alpha_s$.  Furthermore, one can check that, say, $\barbell{barbell_blue}\barbell{barbell_blue}\barbell{barbell_red}\barbell{alpha_blue} = \alpha_s^2 \alpha_t$.  
	Please note that $x \mapsto xf$ does not get a similar abbreviation.  So, $\barbell{alpha_blue}\barbell{barbell_blue} \neq \alpha_s$.
	\ii We will work \emph{modulo lower terms}.  That is, any map which contains a connected component that touches any boundary only once (total) is considered zero.  So, for example, we have $\barbell{break_blue} = 0$.
\end{enumerate}
Henceforth, we will refer to diagrams and their associated polynomials interchangeably.

One can verify that, using the barbell-forcing rules, we can recursively move all barbells to the left, and any ``broken'' walls are reduced to zero, or are contracted.  Hence, any full-diagram can be reduced to linear combinations of maps of the form $f \mapsto \alpha_s^m \alpha_t^n f$.  In other words, every full diagram can be represented as a polynomial in $\RR[x,y][\alpha_s,\alpha_t]$.

In fact, we can even show that, with this new convention, that the following identity holds for every $f$:
\begin{equation}
	\barbell{alpha_blue} f = \partial_s(f) \barbell{break_blue} + s(f) \barbell{alpha_blue}
	\label{eq:barbell_break}
\end{equation}
where $\partial_s$ is the Demazure operator defined in Section~\ref{sec:prelim_genrel}.

\subsubsection{Quantum Numbers}
A particularly nice sequence of polynomials involved can be defined recursively.  They are termed \emph{two-color quantum numbers}.
\begin{definition*}[Quantum Numbers]
	For each integer $n \ge 0$, define two polynomials $[n]_x, [n]_y \in \ZZ[x,y]$ recursively by $[0]_x = [0]_y = 0$, $[1]_x = [1]_y = 1$, $[2]_x = x$, $[2]_y = y$, and
	\begin{align*}
		[2]_x[n]_y = [n+1]_x - [n-1]_x \\
		[2]_y[n]_x = [n+1]_y - [n-1]_y
	\end{align*}
	Finally, $[-n]_x = -[n]_x$ and $[-n]_y = -[n]_y$ for each $n \ge 0$.
\end{definition*}
The quantities $[n]_x$ and $[n]_y$ are closely related.  In particular, $[2k+1]_x = [2k+1]_y$ and $[2]_x[2k]_y = [2]_y[2k]_x$ for all integers $k$.

The quantum numbers are relevant to the problem because of the identity
\begin{equation}
	s([n]_x\alpha_s + [n-1]_y\alpha_t) = [n]_x\alpha_s + [n+1]_y\alpha_t
	\label{eq:quantum}
\end{equation}
and its analogous form for $t$.  One can verify \eqref{eq:quantum} immediately follows from definitions.  This allows us to recursively compute the polynomial which results from pushing a barbell through multiple alternating fences.  For example, $ststst(\alpha_s) = ststst([1]_x\alpha_s + [0]_y\alpha_t) = [7]_x\alpha_s + [6]_y\alpha_t$.

This motivates us to make the following definition, which will be used in Section~\ref{sec:res_alt_compute}.
\begin{definition*}
	For any reduced expression $\ul r$, we adopt the quantum polynomial $Q_{\ul r}$ by :
	\[
		Q_{\AA_n} = 
		\begin{cases}
			[n+1]_x \alpha_s + [n]_y \alpha_t & \text{if $n$ is odd} \\
			[n]_x \alpha_s + [n+1]_y \alpha_t & \text{if $n$ is even}
		\end{cases}
	\]
	when $\ul r = \AA_n$, and otherwise,
	\[
		Q_{\AA_n'} =
		\begin{cases}
			[n]_x \alpha_s + [n+1]_y \alpha_t & \text{if $n$ is even} \\
			[n+1]_x \alpha_s + [n]_y \alpha_t & \text{if $n$ is odd}.
		\end{cases}
	\]
\end{definition*}

It is easy to observe that if $\ul r$ is a reduced expression of length $n+1$, then \[ \MM_{\ul r} ( \underbrace{11\dots11}_{\text{$n$ 1's}}0, \underbrace{11\dots11}_{\text{$n$ 1's}}0 ) = Q_{\ul r}. \]


\section{Problem Statement}
\label{sec:probstate}

The motivation for this problem arises from the following definition.
\begin{definition*}
	A map is \emph{idempotent} if multiplying it with itself returns the original graph.
\end{definition*}
Colloquially, $m^2=m$ if and only if $m$ is idempotent.

Fix an $\ul r$.  If we can find two maps $A$ and $B$ for which $AB$ is the identity, then $(BA)^2=BABA=BA$ will be an idempotent.  This motivates us to construct potential idempotents by taking two light leaves whose top sequences are identical, and composing $A$ upside-down with $B$.  If $AB=1$, then this will yield an idempotent.

This motivates the main objective of study.
\begin{ques*}
	For a fixed $\ul r$ and two binary sequences $\ul a$ and $\ul b$ with $\Top_{\ul r}(\ul a) = \Top_{\ul r}(\ul b)$, find a formula for $\MM_{\ul r}(\ul a, \ul b)$ in terms of $\ul r$, $\ul a$, and $\ul b$.
\end{ques*}
Here, we are interested in computing the polynomial which corresponds to this map.

\section{A Complete Characterization of the One-Color Case}
\label{sec:res_onecolor}
In this section we provide a complete characterization for the $\MM_{\SS_n}(\ul a, \ul b)$.  % The proof is effectively trivial, but requires some rather irritating details and definitions in order to be clear.

First, we need a criteria to determine the top.  Fortunately, this is extremely easy.
\begin{definition*}
	For a binary string $\ul b$, let $\pi_1(\ul b)$ denote the number of $1$'s in $\ul b$, and $\pi_0(\ul b)$ the number of $0$'s.
\end{definition*}
\begin{proposition}
	For any $\ul b \in \BB_n$, \[
		\Top_{\SS_n}(\ul b) =
		\begin{cases}
			\varnothing & \text{if } \pi_1(\ul b) \equiv 0 \pmod{2} \\
			s & \text{if } \pi_1(\ul b) \equiv 1 \pmod{2}.
		\end{cases}
		\]
	\label{prop:s_top}
\end{proposition}
\begin{proof}
	Straightforward induction on $n$.  
\end{proof}

Subsequently, we make the following definition.
\begin{definition*}
	For a binary string $\ul b$, define the \emph{partial-sum string} of $\ul b$, denoted $\ul b^\ast$, as follows:
	\[
		\ul b^\ast [i] = 
		\begin{cases}
			1 & \text{if } \ul b[1] + \ul b[2] + \dots + \ul b[i] \equiv 1 \pmod{2} \\
			0 & \text{otherwise}.
		\end{cases}
	\]
\end{definition*}
This lets us state our main result for this section. 
\begin{theorem}
	If $\ul a, \ul b \in \BB_n$ obey $\Top_{\SS_n}(\ul a) = \Top_{\SS_n}(\ul b)$, then
	\[
		\MM_{\SS_n} \left( \ul a, \ul b \right)
		=
		\begin{cases}
			0 & \text{if }\ \exists 1 \le i \le n-1:\ \ul a^\ast[i] = \ul b^\ast[i] = 1 \\
			\alpha_s^{n - \pi_1(\ul a^\ast) - \pi_1(\ul b^\ast) - \ul a^\ast[n]} & \text{otherwise}.
		\end{cases}
	\]
	\label{thm:s_eval}
\end{theorem}
The proof is given in Appendix~\ref{sec:s_proof}; it is essentially only a matter of finding loops and counting connected components.

\section{Counting Maps}
\label{sec:res_count_maps}
We give a formula for the number of binary strings $\ul b$ such that $\Top_{\ul r}(\ul b) = \ul T$ for each expression $\ul T$ and $\ul r$.  One can check that, by construction, $\Top(\ul b)$ is always a reduced expression.

\begin{definition*}
	Let $R(\ul r)$ denote $\ul r$ with any consecutive blocks of $s$'s replaced by a single $s$, and similarly for $t$.
\end{definition*}
For example, $R(sststttts) = ststs$.

\begin{proposition}
	Let $\ul r$ be an expression of length $\ell$, and suppose $R(\ul r) = \AA_n$.
	\begin{enumerate}[(i)]
		\ii If $n=2k+1$ is odd, then for each $0 \le m \le k$, there are $2^{\ell-n} \binom{2k}{m+k}$ binary strings $\ul b$ yielding each of $\AA_{2m+1}$, $\AA_{2m}$, $\AA_{2m-1}'$, and $\AA_{2m}'$ as $\Top_{\ul r}(\ul b)$.
		\ii If $n=2k$ is even, then for each $0 \le m \le k-1$, there are $2^{\ell-n} \binom{2k-1}{m+k}$ binary strings $\ul b$ yielding each of $\AA_{2m+1}$, $\AA_{2m+2}$, $\AA_{2m}'$, and $\AA_{2m+1}'$ as $\Top_{\ul r}(\ul b)$.
	\end{enumerate}
	\label{thm:count_maps}
\end{proposition}
Of course, if $\ul r$ begins with the character $t$, then one can simply reverse the roles of $s$ and $t$ in the above theorem to obtain an analogous formula.

The main idea of the proof is to reduce the problem to the case when $\ell = n$, and then apply induction on $n$.  We fill in the details below.

\begin{proof}[Proof of Proposition \ref{thm:count_maps}]
	First we will resolve the case where $\ul r = \AA_n$, so that $\ell = n$ and $2^{\ell-n} = 1$.  This follows by induction on $n$.  The main idea is that, for the binary strings of length $n$, we consider those that end with $1$ and those that end with $0$.  Those that end with a $0$ have the same top when the trailing $0$ is deleted, whilst those with end bit $1$ have a top which differs by one character if the trailing $1$ is deleted.  We simply check that in all eight cases, the binomial coefficients add up to give the new binomial coefficients (via Pascal's identity).  The computation is left to a reader.

	To finish to all cases, we note that we can treat each consecutive block of $s$'s of length $m$ as a single $s$, where there a $2^{m-1}$ ways to get a $1$ and $2^{m-1}$ ways to get a $0$.  (This follows from Proposition \ref{prop:s_top}.)  This reduces to the previous case $\ul r = \AA_n$, but with some extra factors of $2$; aggregating all of them yields the factor of $2^{\ell-n}$, as desired.
\end{proof}

\section{Colorful Lemmata for the Alternating Case}
\label{sec:res_alt_restrict}
We now turn our attention to the case of $\ul r = \AA_n$.

In this section we will show several results which show that the possible outputs of a map with base $\AA_n$ are extremely restricted.  The proofs are given in Appendix~\ref{sec:lemmata_proof}.
\begin{lemma}[Bubble Lemma]
	Consider a bubble in a full-diagram with base $\AA_n$.  The bubble holds exactly one caterpillar, whose color is opposite that of the bubble.
	\label{thm:bubble}
\end{lemma}
\begin{lemma}[Caterpillar Lemma]
	Any caterpillar in a full-diagram with base $\AA_n$ evaluates in the form $x^my^n\alpha_s$ if it is blue, or $x^my^n\alpha_t$ is red.
	\label{thm:caterpillar}
\end{lemma}
\begin{lemma}[Pasture Lemma]
	Consider a full-diagram with $N+1$ pastures (numbered $0$, $1$, \dots, $N$) with base $\AA_n$ and top $T$.  Suppose further that $N \ge 1$ (or equivalently, $T \neq \varnothing$).  Then:
	\begin{enumerate}[(i)]
		\ii Pastures $1$ through $N-1$ contain either nothing or an attached component.
		\ii Pasture $N$ contains nothing if $T[N] = \AA_n[n]$, and contains a single caterpillar otherwise, with color corresponding to $\AA_n[n]$.
	\end{enumerate}
	\label{thm:pasture}
\end{lemma}
These results show that the structure in maps with base $\AA_n$ is quite limited.  

\section{Algebraic Computations for the Alternating Case}
\label{sec:res_alt_compute}
We now turn to using the tools developed in Section~\ref{sec:res_alt_restrict} in order to compute polynomials. First, we add some structure to these special cases.

\subsection{Restrictions and Definitions for the Final Output}
Let us now endow our maps with base $\AA_n$ with some additional structure.
\begin{theorem}
	For any binary strings $\ul a, \ul b \in \BB_n$, if $\MM_{\AA_n} (\ul a, \ul b)$ is nonzero and has top $T$, then for some nonnegative integers $m_x$, $m_y$, $m_s$, and $m_t$, we have 
	\[
		\MM_{\AA_n} (\ul a, \ul b) =
		x^{m_x}y^{m_y}\alpha_s^{m_s}\alpha_t^{m_t} \cdot
		\begin{cases}
			1 & \text{if $T$ and $\AA_n$ have the same last character} \\
			Q_T & \text{otherwise}.
		\end{cases}
	\]
	\label{thm:alt_struct}
\end{theorem}
\begin{proof}
	This is an immediate consequence of the Caterpillar Lemma and the Pasture Lemma.  Everything in the first pasture is a product of monomials by the Caterpillar Lemma.  If $T$ and $\AA_n$ agree, then the last pasture is empty and hence we obtain the first case.  Otherwise, there is a single caterpillar of color opposite to $T$, and hence after evaluating that caterpillar, we obtain some monomial times a single barbell.  This generates the final $Q_T$ term.
\end{proof}

This motivates the following definition.
\begin{definition*}
	If a nonzero map $M$ with base $\AA_n$ is presented as in Theorem~\ref{thm:alt_struct}, then the term $x^{m_x}y^{m_y}\alpha_s^{m_s}\alpha_t^{m_t}$ will be called the \emph{fluff} of $M$, and the polynomial (either $1$ or $Q_T$) will be the \emph{face} of $M$. 
\end{definition*}
\begin{remark*}
	According to Theorem~\ref{thm:alt_struct}, a nonzero map $\MM_{\AA_n}$ has face $1$ and only if its top has the same last character as $\AA_n$.
\end{remark*}

\subsection{A Partial Recursion}
In this section we present a limited recursion for computing $\MM_{\AA_n}(\ul a, \ul b)$.  The proof is given in Appendix~\ref{sec:recurse_proof}.

\begin{proposition}
	Let $n \ge 2$ be an odd integer and consider two binary strings $\ul a, \ul b \in \BB_n$ such that $T = \Top_{\AA_n}(\ul a) = \Top_{\AA_n}(\ul b)$.  
	Let $\ul a'$ and $\ul b'$ are the first $n-1$ bits of $\ul a$ and $\ul b$, respectively. 
	Suppose $M_1 = \MM_{\AA_{n-1}} \left(\ul a', \ul b'\right)$ is a nonzero map with fluff $F$.
	\begin{enumerate}[(i)]
		\ii If $\ul a[n] = \ul b[n] = 0$, then
		\[ \MM_{\AA_n} (\ul a, \ul b)
			=
			\begin{cases}
				M_1 \alpha_s & \text{if $T = \varnothing$} \\ % just another barbell
				-xF & \text{if $T$ ends in $s$} \\ % closes a caterpillar like 0|
				M_1 Q_T & \text{if $T$ ends in $t$}. \\ % just another barbell, but push it all the way through nonempty T
			\end{cases}
		\]
		\ii If $\ul a[n] = \ul b[n] = 1$, then
		\[
			\MM \AA_n (\ul a, \ul b)
			=
			\begin{cases}
				-x\alpha_sF & \text{if $T = \varnothing$} \\ % destructive 1, closes a caterpillar O
				M_1 & \text{if $T$ ends in $s$} \\ % constructive 1
				-xF Q_T & \text{if $T$ ends in $t$}. % destructive 1
			\end{cases}
		\]
	\end{enumerate}
	Analogous statements hold when $n$ is an even integer, with the roles of $x$ and $y$ interchanged, as well as the roles of $s$ and $t$.
	\label{thm:recurse}
\end{proposition}

Notice that this recursion is sufficient to calculate $\MM_{\AA_n}(\ul b, \ul b)$.


\section{Conclusion}
The overarching goal of the paper was to compute $\MM_{\ul r} (\ul a, \ul b)$ in terms of $\ul r$, $\ul a$, and $\ul b$.  In this paper, we solved the case where $\ul r = \SS_n$ completely, and showed that the case where $\ul r = \AA_n$ is significantly restricted.  We also provide a partial recurrence for $\AA_n$.  One obvious next direction would be to attempt to complete the recursion for $\AA_n$ so that $\MM_{\AA_n} (\ul a, \ul b)$ can be determined completely.

What about the original problem of arbitrary $\ul r$?  It was originally hoped that, by understanding $\AA_n$ and $\SS_n$, one could derive the general formula (perhaps by viewing strings of $s$'s in $\ul r$ as a single $s$ with a formula for $\SS_n$, and then aggregating all this information with a formula for $\AA_n$).  Unfortunately, the lemmata of Section~\ref{sec:res_alt_restrict} show that in fact, maps with base $\AA_n$ are quite restricted.  So, either the results of Section~\ref{sec:res_alt_compute} will have to be generalized significantly (in the context of maps outside those of base $\AA_n$), or an entirely new approach will be required.

\section{Acknowledgments} 
I wish to thank the MIT Math Department for organizing the Math RSI, and in particular the head mentor Dr. Tanya Khovanova, MIT, for providing individual discussion with me.
I also wish to thank my tutor Mr. Antoni Rangachev, Northeastern University, for his invaluable advice in preparing both this paper and my final presentation.
I also thank the Center for Excellence in Education and the Research Science Institute, as well as the Massachusetts Institute of Technology, for generously providing the facilities for the research.

I would also like to thank my sponsors from RSI 2013:
\begin{inparaenum}[]
	\ii Ms. Alexa Margalith, The Leonetti/O'Connell Family Foundation;
	\ii Mr. Arvind Parthasarathi, YarcData;
	\ii Mr. Samuel Chen and Ms. Kathy Chang;
	\ii Dr. Robert E. Curry;
	\ii Mr. and Mrs. William Hellman;
	\ii Mr. Ronald Houhauser;
	\ii Ms. Chienlan Hsu-Hoffman; and
	\ii Mr. and Mrs. George Keiter.
\end{inparaenum}

Finally, I offer my sincerest gratitude to my mentor Mr. Francisco Unda, MIT, for daily mentorship, and Professor Benjamin Elias, MIT, for providing the project and for often meeting with me personally to discuss it.
That sounded horribly fake, but I really mean it.  You guys are the best.  Thank you for a great project.
